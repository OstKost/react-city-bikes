{"version":3,"sources":["library/common/commonComponents/Layout/style.module.scss","library/common/commonActions/networksActions.ts","library/common/commonActions/stationsActions.ts","library/common/commonActions/likedStationsActions.ts","library/common/commonActions/index.ts","library/common/commonConstants/networksConstants.ts","library/common/commonConstants/stationsConstants.ts","library/common/commonConstants/likedStationsConstants.ts","library/common/commonConstants/index.ts","library/common/commonReducers/networksReducer.ts","library/common/commonReducers/stationsReducer.ts","library/common/commonReducers/likedStationsReducer.ts","main/mainReducer.ts","library/utilities/axiosInstances.ts","library/api/networks.api.ts","library/common/commonSagas/networksSagas.ts","library/common/commonSagas/stationsSagas.ts","library/api/stations.api.ts","main/mainSaga.ts","main/store/configureStore.ts","library/common/commonComponents/PageLoader/PageLoader.tsx","main/Routes.tsx","library/common/commonComponents/Layout/Layout.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","fetchNetworks","type","FetchNetworksTypes","FETCH_NETWORKS","payload","fetchNetworksSuccess","FETCH_NETWORKS_SUCCESS","fetchNetworksError","error","FETCH_NETWORKS_ERROR","message","fetchStations","id","FetchStationsTypes","FETCH_STATIONS","fetchStationsSuccess","FETCH_STATIONS_SUCCESS","fetchStationsError","FETCH_STATIONS_ERROR","toggleLikeStations","newState","LikeStationTypes","LIKE_STATION","DISLIKE_STATION","INIT_STATE","networks","isLoading","undefined","stations","likedStations","mainReducer","combineReducers","state","action","filter","st","axios","create","baseURL","get","fetchNetworksRequest","watchFetchNetworksRequest","call","data","delay","put","takeLatest","fetchStationsRequest","watchFetchStationsRequest","network","mainSaga","root","all","fork","persistConfig","key","storage","blacklist","persistedReducer","persistReducer","sagaMiddleware","createSagaMiddleware","composeEnhancer","compose","store","createStore","applyMiddleware","persistor","persistStore","run","PageLoader","style","textAlign","Networks","Loadable","loader","loading","Dashboard","NotFound","Routes","path","exact","component","to","Layout","children","className","styles","container","nav","navLink","activeClassName","activeNavLink","content","App","basename","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.8e43e159.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"style_container__1uFTI\",\"nav\":\"style_nav__-I8X3\",\"navLink\":\"style_navLink__2muN1\",\"activeNavLink\":\"style_activeNavLink__RN0s-\",\"content\":\"style_content__3_RhZ\"};","import { FetchNetworksTypes } from 'library/common/commonConstants';\nimport { Network } from 'library/interfaces';\n\nexport const fetchNetworks = () => ({\n  type: FetchNetworksTypes.FETCH_NETWORKS,\n  payload: null\n});\n\nexport const fetchNetworksSuccess = (payload: Network[]) => ({\n  type: FetchNetworksTypes.FETCH_NETWORKS_SUCCESS,\n  payload\n});\n\nexport const fetchNetworksError = (error: Error) => ({\n  type: FetchNetworksTypes.FETCH_NETWORKS_ERROR,\n  payload: error.message\n});\n","import { FetchStationsTypes } from 'library/common/commonConstants';\nimport { Station } from 'library/interfaces';\n\nexport const fetchStations = (id: string) => ({\n  type: FetchStationsTypes.FETCH_STATIONS,\n  payload: id\n});\n\nexport const fetchStationsSuccess = (payload: Station[]) => ({\n  type: FetchStationsTypes.FETCH_STATIONS_SUCCESS,\n  payload\n});\n\nexport const fetchStationsError = (error: Error) => ({\n  type: FetchStationsTypes.FETCH_STATIONS_ERROR,\n  payload: error.message\n});\n","import { LikeStationTypes } from 'library/common/commonConstants';\n\nexport const toggleLikeStations = (id: string, newState: boolean) => ({\n  type: newState\n    ? LikeStationTypes.LIKE_STATION\n    : LikeStationTypes.DISLIKE_STATION,\n  payload: id\n});\n","export * from './networksActions';\nexport * from './stationsActions';\nexport * from './likedStationsActions';\n","export enum FetchNetworksTypes {\n  FETCH_NETWORKS = '@@NETWORKS/GET_ALL',\n  FETCH_NETWORKS_SUCCESS = '@@NETWORKS/GET_ALL_SUCCESS',\n  FETCH_NETWORKS_ERROR = '@@NETWORKS/GET_ALL_ERROR'\n}\n","export enum FetchStationsTypes {\n  FETCH_STATIONS = '@@STATIONS/GET_BY_ID',\n  FETCH_STATIONS_SUCCESS = '@@STATIONS/GET_BY_ID_SUCCESS',\n  FETCH_STATIONS_ERROR = '@@STATIONS/GET_BY_ID_ERROR'\n}\n","export enum LikeStationTypes {\n  LIKE_STATION = '@@STATIONS/LIKE_STATION',\n  DISLIKE_STATION = '@@STATIONS/DISLIKE_STATION'\n}\n","export * from './networksConstants';\nexport * from './stationsConstants';\nexport * from './likedStationsConstants';\n","import { Network, IAction } from 'library/interfaces';\nimport { FetchNetworksTypes } from 'library/common/commonConstants';\n\nexport interface NetworksState {\n  networks: Network[];\n  isLoading: boolean;\n  error: string | undefined;\n}\n\nconst INIT_STATE: NetworksState = {\n  networks: [],\n  isLoading: false,\n  error: undefined\n};\n\nexport const networks = (state = INIT_STATE, action: IAction) => {\n  switch (action.type) {\n    // Networks\n    case FetchNetworksTypes.FETCH_NETWORKS:\n      return { ...state, isLoading: true, error: undefined };\n    case FetchNetworksTypes.FETCH_NETWORKS_SUCCESS:\n      return {\n        ...state,\n        isLoading: false,\n        error: undefined,\n        networks: action.payload\n      };\n    case FetchNetworksTypes.FETCH_NETWORKS_ERROR:\n      return { ...state, isLoading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n","import { FetchStationsTypes } from 'library/common/commonConstants';\nimport { Station, IAction } from 'library/interfaces';\n\nexport interface StationsState {\n  stations: Station[];\n  isLoading: boolean;\n  error: string | undefined;\n}\n\nconst INIT_STATE: StationsState = {\n  stations: [],\n  isLoading: false,\n  error: undefined\n};\n\nexport const stations = (state = INIT_STATE, action: IAction) => {\n  switch (action.type) {\n    case FetchStationsTypes.FETCH_STATIONS:\n      return { ...state, isLoading: true, error: undefined, stations: [] };\n    case FetchStationsTypes.FETCH_STATIONS_SUCCESS:\n      return {\n        ...state,\n        isLoading: false,\n        error: undefined,\n        stations: action.payload\n      };\n    case FetchStationsTypes.FETCH_STATIONS_ERROR:\n      return { ...state, isLoading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n","import { LikeStationTypes } from 'library/common/commonConstants';\nimport { IAction } from 'library/interfaces';\n\nexport interface LikedStationsState {\n  likedStations: string[];\n}\n\nconst INIT_STATE: LikedStationsState = {\n  likedStations: []\n};\n\nexport const likedStations = (state = INIT_STATE, action: IAction) => {\n  switch (action.type) {\n    case LikeStationTypes.LIKE_STATION:\n      return {\n        ...state,\n        likedStations: [...state.likedStations, action.payload]\n      };\n    case LikeStationTypes.DISLIKE_STATION:\n      return {\n        ...state,\n        likedStations: state.likedStations.filter(st => st !== action.payload)\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from 'redux';\nimport {\n  networks,\n  NetworksState,\n  stations,\n  StationsState,\n  likedStations,\n  LikedStationsState\n} from 'library/common/commonReducers';\n\nexport interface State {\n  networks: NetworksState;\n  stations: StationsState;\n  likedStations: LikedStationsState;\n}\n\nexport const mainReducer = combineReducers<State>({\n  networks,\n  stations,\n  likedStations\n});\n","import axios from 'axios';\n\nconst API_URL = 'https://api.citybik.es/v2';\n\nexport const networks = axios.create({\n  baseURL: `${API_URL}/networks`\n});\n","import { networks } from 'library/utilities/axiosInstances';\n\nexport const fetchNetworks = () => {\n  return networks.get('?fields=id,name');\n};\n","import { call, put, takeLatest, delay } from 'redux-saga/effects';\nimport { fetchNetworks } from 'library/api';\nimport {\n  fetchNetworksSuccess,\n  fetchNetworksError\n} from 'library/common/commonActions';\nimport { FetchNetworksTypes } from 'library/common/commonConstants';\n\nfunction* fetchNetworksRequest() {\n  try {\n    const { data } = yield call(fetchNetworks);\n    yield delay(500);\n    yield put(fetchNetworksSuccess(data?.networks));\n  } catch (error) {\n    yield put(fetchNetworksError(error));\n  }\n}\n\nexport function* watchFetchNetworksRequest() {\n  yield takeLatest(FetchNetworksTypes.FETCH_NETWORKS, fetchNetworksRequest);\n}\n","import { call, put, takeLatest, delay } from 'redux-saga/effects';\nimport { fetchStations } from 'library/api';\nimport {\n  fetchStationsSuccess,\n  fetchStationsError\n} from 'library/common/commonActions';\nimport { FetchStationsTypes } from 'library/common/commonConstants';\nimport { IAction } from 'library/interfaces';\n\nfunction* fetchStationsRequest(action: IAction) {\n  try {\n    const { data } = yield call(() => fetchStations(action.payload));\n    yield delay(500);\n    yield put(fetchStationsSuccess(data?.network?.stations));\n  } catch (error) {\n    yield put(fetchStationsError(error));\n  }\n}\n\nexport function* watchFetchStationsRequest() {\n  yield takeLatest(FetchStationsTypes.FETCH_STATIONS, fetchStationsRequest);\n}\n","import { networks } from 'library/utilities/axiosInstances';\n\nexport const fetchStations = (id: string) => {\n  return networks.get(`/${id}`);\n};\n","import { all, fork } from 'redux-saga/effects';\nimport {\n  watchFetchNetworksRequest,\n  watchFetchStationsRequest\n} from 'library/common/commonSagas';\n\nexport const mainSaga = function* root() {\n  yield all([fork(watchFetchNetworksRequest), fork(watchFetchStationsRequest)]);\n};\n","import { createStore, compose, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport createSagaMiddleware from 'redux-saga';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage'; // localStorage\n\nimport { mainReducer } from 'main/mainReducer';\nimport { mainSaga } from 'main/mainSaga';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n  blacklist: ['stations']\n};\n\nconst persistedReducer = persistReducer(persistConfig, mainReducer);\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst composeEnhancer =\n  process.env.NODE_ENV !== 'production' ? composeWithDevTools({}) : compose();\n\nexport let store = createStore(\n  persistedReducer,\n  {},\n  composeEnhancer(applyMiddleware(sagaMiddleware))\n);\n\nexport let persistor = persistStore(store);\n\nsagaMiddleware.run(mainSaga);\n","import React from 'react';\n\nconst PageLoader = () => {\n  return (\n    <div style={{ textAlign: 'center' }}>\n      <h2>Loading...</h2>\n    </div>\n  );\n};\n\nexport default PageLoader;\n","import React from 'react';\nimport { Switch, Route, Redirect } from 'react-router-dom';\nimport Loadable from 'react-loadable';\nimport PageLoader from 'library/common/commonComponents/PageLoader/PageLoader';\n\nconst Networks = Loadable({\n  loader: () => import('modules/Networks/NetworksContainer'),\n  loading: PageLoader\n});\nconst Dashboard = Loadable({\n  loader: () => import('modules/Dashboard/DashboardModule'),\n  loading: PageLoader\n});\nconst NotFound = Loadable({\n  loader: () => import('modules/NotFound/NotFoundModule'),\n  loading: PageLoader\n});\n\nconst Routes = () => {\n  return (\n    <Switch>\n      <Route path='/' exact component={Dashboard} />\n      <Route path='/networks' exact component={Networks} />\n      <Route path='/networks/:networkId' exact component={Networks} />\n      <Route path='/404' component={NotFound} />\n      <Redirect to='/404' />\n    </Switch>\n  );\n};\n\nexport default Routes;\n","import React from 'react';\nimport { NavLink } from 'react-router-dom';\nimport styles from './style.module.scss';\n\nconst Layout = ({ children }: any) => {\n  return (\n    <div className={styles.container}>\n      <nav className={styles.nav}>\n        <NavLink\n          className={styles.navLink}\n          activeClassName={styles.activeNavLink}\n          to='/'\n          exact\n        >\n          Home\n        </NavLink>\n        <NavLink\n          className={styles.navLink}\n          activeClassName={styles.activeNavLink}\n          to='/networks'\n        >\n          Networks\n        </NavLink>\n      </nav>\n      <main className={styles.content}>{children}</main>\n    </div>\n  );\n};\n\nexport default Layout;\n","import React from 'react';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter } from 'react-router-dom';\nimport { PersistGate } from 'redux-persist/integration/react';\n\nimport { store, persistor } from 'main/store/configureStore';\nimport Routes from 'main/Routes';\nimport Layout from 'library/common/commonComponents/Layout/Layout';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <BrowserRouter basename='react-city-bikes'>\n          <Layout>\n            <Routes />\n          </Layout>\n        </BrowserRouter>\n      </PersistGate>\n    </Provider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}